[{"uri":"https://djmolprogram.github.io/","title":"DJMol Docs","tags":[],"description":"","content":"Welcome to DJMol Modeling Platform DJMol is an open source (GPL v3), free, Object-oriented Modeling Platform specially designed for Computational Materials Science and Computational Chemistry. At present it is integrated with DFTB+ (default modeling engine), along with Siesta, OpenMD, and ASE Python interpreter. At present, it is available for windows 64-bit OS and soon it will be updated for Linux 64-bit OS, with more additions like, NWChem, Huckel Calculators, Reaction rate modules\nSome of the Tasks* that DJMol can Perform/Analyze/Calculate is:\n DFTB+ or Siesta Molecular/Nano system calculations Visualization of Orbitals, Partial Charges, / (projected-) Density of states, Band structures Viewing Phonon/IR modes, Intensities (including velocity auto-correlation via Fast Fourier Transform), UV-Vis Spectra (i.e. Time Dependent DFTB) Python scripting with ASE (Transition State Search/ Reaction Path) Vibrational Modes Molecular dynamics/Trajectories Symmetry of Structure, 2D, 1D Potential energy surfaces Generate Nano-/Molecular Structures, and its Conversions Cloud based remote computing (SSH) etc.   The DJMol project evolved under the leadership of Dr.Krishna Mohan G. P., (Asst. Prof. of Chemistry, Department of Science and Humanities, Mar Baselios College of Science and Technology (MBCET), Trivandrum, Kerala, India: 695015, Rahul Sunil (BTech in Computer Science, MBCET), Dr. Kapil Gupta and Dr. Seung C Lee (Indo-Korea Science and Technology Center, Bengaluru, Karnataka, India: 560064). The program is developed by IKST, Bengaluru, India.\n Documentation DJMol\u0026rsquo;s online manual is available here. PDF manual is also available.\nDownload and Installation For getting the source code and compiling instruction click here\nMailing List We strongly encourage DJMol users to join its users forum. Please visit https://djmol.forumotion.com/ to join the Forum\nLicense The Program is distributed under GPL-v3 (or later). For a detailed review on this license visit GNU Project\nContact Mail krishna.mohan@mbcet.ac.in or krishnamohan.gp@gmail.com for further queries on the program.\n"},{"uri":"https://djmolprogram.github.io/installation/","title":"Installation","tags":[],"description":"","content":"DJMol Download and Installation  Download   Binaries   Source   For Compiling/Installation of DJMol and Add-Ons General Information A familiarity with programming using Netbeans IDE is assumed. All of the DJMol Program was compiled by using Netbeans IDE, v 8.2 (64bit) in Windows 64 OS.\n   The needed Packages are:     JAVA 1.8 (jdk-8u201-windows-x64.exe) Netbeans 8.2 (netbeans-8.2-javaee-windows.exe) Python plug-in (2017-08-29-nbpython-nbms.zip) Python 3.7.2 (python-3.7.2-amd64.exe) Pip script (get-pip.py) Numpy (numpy-1.16.0+mkl-cp37-cp37m-win_amd64.whl)     We also used (64 bit) the following Python packages with version numbers:     SciPy (scipy 1.2.1) ASE (ASE 3.17.0) Matplotlib (Matplotlib 3.0.3)   And these modules can be downloaded by using pip (use pip3).\n    A. Compiling Main Program     Open the Project Directory, DJmol Platform v2.1 and Compile and Build DJMol program. See the YouTube channel for its demonstration. Then make a Zip Distribution (by Selecting project DJmol Platform v2.1 followed by selecting Package as, Zip Distribution). A new dist folder will be created and it holds the Zip file.     B. Installing Program    Go to dist folder and unzip the file and Copy all the files/folders from the Auxiliary folder into *** dist\\djmolplatform1***. This is shown in the demonstration. Go to dist\\djmolplatform1\\etc and replace the following line in the djmolplatform1.CONF file: default_options=\u0026quot;--branding djmolplatform1 -J-Xms24m -J-Xmx64m\u0026quot;  to default_options=\u0026quot;--branding djmolplatform1 -J-Xms240m -J-Xmx640m\u0026quot; To adjust the Resolution of the program Right click on djmolplatform164.exe then move to Compatibility tab and click on *** Change high DPI settings*** and Select the option \u0026ldquo;Override high DPI scaling behavior\u0026rdquo;. Follow the instruction in the PathVariablesSetting.pdf file.  DJMol program can be now simply executed by double clicking djmolplatform164.exe which is located in bin folder.\nNote that for the First Time of the execution, you may want to select, Disable Modules and Continue option. To fix this, you can try to clean your user-directory as it is mentioned in http://wiki.netbeans.org/FaqWhatIsUserdir\nAnd once the application starts do the following (not mandate but it is useful):\nClose \u0026lt;Start Page\u0026gt; Close \u0026lt;Services\u0026gt; Add \u0026lt;Windows -\u0026gt; Favorites\u0026gt; Add \u0026lt;Windows -\u0026gt; Output\u0026gt;    C. Compiling Add-On Programs    See AddOns_compilation.txt in Add-On directory.\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter1/","title":"Chaper 1","tags":[],"description":"","content":"Chapter 1: Introduction DJMol is an ongoing open source (licensed with GPL v3 or later) ‘Modeling Platform’ project and it is architectured for performing various simulations in computational materials science / chemistry. It is a free, object-oriented software developed by IKST, (Indo-Korea Science and Technology Centre, 17/1, Bellary Rd, Yashoda Nagar, Yelahanka, Bengaluru, Karnataka 560064), Bangalore.\nIn its core level, DJMol is integrated with widely accepted and open source (GPL/LGPL ) computational software, such as,\nDFTB+ (University of Bremen, Germany), the default calculator of DJMol\nAtomic Simulation Environment (ASE, Technical University of Denmark)\nSIESTA (Institut de Ciencia de Materials de Barcelona (ICMAB), Spain)\nOpenMD (University of Notre Dame., USA).\nThe main target of this software is the researchers (including experimentalists) and academicians and industrial researchers. In addition to this, a site, https://sites.google.com/view/djmolplatfor m is created for more technical details, updates and demonstration videos/notes etc. The code-development resources are recently included in its official site, www.djmol.info .\nAs mentioned before, the software is integrated with DFTB+ (as its default calculator), and Siesta (for higher level DFT calculations), along with ASE and OpenMD,. Hence a short review on these packages is added for a quick-reference.\nComputational Tools\nHere, a short overview of the four main components of the platform is described.\nDFTB+: DFTB (Density functional tight binding) method is an electronic structure method which is specially designed to model large molecular/crystal/nano-systems. The origin of this method is routed in DFT itself, which is, arguably, the most popular ab initio method in computational materials science or in quantum chemistry. It is developed in 80’s and it has been introduced into the computational chemistry area mainly by work of Prof. Helmut Eschrig, Prof. Gotthard Seifert, and Prof. Thomas Frauenheim et. al. Since it uses DFT parameters, DFTB is also known as approximate DFT method.\nThis method uses atomic parameters (as it is stored in the SK file set, a text file) which are generated from highly accurate atomic DFT calculations using PBE functional. It also consists of diatomic repulsive potentials from B3LYP functional. Note that DFTB+ uses minimal valence basis set (numerical Slater type AOs) and one has to explicitly specify a particular SK data file for a given calculation.\nA list of SK file set list is given below (see, www.dftb.org), which is by default, added in the DJMol suite. Other SK file which are not included (such as, \u0026lt;3ob:freq\u0026gt; set which requires \u0026lt;3ob\u0026gt;) should manually incorporate into their input scripts (it is freely available); For more details, see:\nhttps://www.dftbplus.org/ and\nhttps://www.dftb.org/parameters/download/\nTable 1: Set of common SK data set\nSIESTA: Spanish Initiative for Electronic Simulations with Thousands of Atoms is a fast (since it uses linear scaling DFT methods) density functional theoretical code which uses pseudopotentials. It can handle molecular as well as extended systems (metals, polymers, defects in the metals, surfaces etc.) It is a free code and for more details see: https://departments.icmab.es/leem/siesta. And routinely it can be used to predict:\n• Total and partial energies.\n• Atomic forces.\n• Stress tensor.\n• Electric dipole moment.\n• Atomic, orbital and bond populations (Mulliken).\n• Electron density.\n• Geometry relaxation, fixed or variable cell.\n• Constant-temperature molecular dynamics (Nose thermostat).\n• Variable cell dynamics (Parrinello-Rahman).\n• Spin polarized calculations (collinear or not).\n• k-sampling of the Brillouin zone.\n• Local and orbital-projected density of states.\n• COOP and COHP curves for chemical bonding analysis.\n• Dielectric polarization.\n• Vibrations (phonons).\n• Band structure.\nNote that at present TranSiesta (electron transport module) is not supported by DJMol\nSince Siesta uses Numerical Atomic Orbital (i.e. localized basis set) as its basis, some familiarity with these sets are highly appreciated. Note that a user can give ‘Basis set’ information to Siesta in two different ways. The most simple method is to provide a ‘keyword’of the basis set. See the next table for its details:\nTable 2: A set of common basis set in Siesta\n   Single-Zeta Double-Zeta Triple-Zeta Single-Zeta Polarized Double-Zeta Polarized Triple-Zeta Polarized Triple-Zeta Double-Polarized     SZ DZ TZ SZP DZP TZP TZDP    However, for advanced calculations a user can also give the basis set data explicitly. Refer Siesta manual for its description.\nApart from the basis set, one should also select an appropriate pseudopotential (PP). For more details, see:\n[1]https://departments.icmab.es/leem/siesta/Pseudopotentials/index.html or,\n[2]https://departments.icmab.es/leem/siesta/Databases/Pseudopotentials/periodictable-gga-abinit.html\nThe first link redirects to ATOM program which can be used to generate PP for elements within the GGA/LDA functionals. The second link gives a database of PP which was converted from the Abinit PP. Note that choosing PP is a crucial step in Siesta calculation so a user must be Very Careful at this step.\nNote: By default, DJMol use PP from the Second link [2].\nFigure 1.1: The pseudopotentials of Abinit which is converted for Siesta (figure courtesy: ICMAB)\nA note on Functionals: In Siesta you can specify either LDA or GGA type functionals in a \u0026lt;.fdf\u0026gt; input file. For example, see below for a part of the file, which define functionals :\nTable 3: Specification of functional in Siesta FDF file.\nXC.functional LDA # Exchange-correlation functional ( GGA can be also used) XC.authors CA # Particular parametrization of xc func. SpinPolarized .false. # Spin unpolarized calculation Table 4: Set of choice of XC.authors (with its type) variables.\n   XC.authors variables     CA (equivalent to PZ) A LDA type   PW92 LDA   PW91 GGA   PBE GGA   revPBE Modified GGA-PBE   RPBE Modified GGA-PBE   WC Modified GGA-PBE   AM05 Modified GGA-PBE   PBEsol Modified GGA-PBE   PBEJsJrLO GGA-PBE   BLYP (equivalent to LYP) GGA   DRSLL (equivalent to DF1) van der Waals density functional (vdW-DF)   LMKLL (equivalent to DF2) vdW-DF functional   KBM vdW-DF functional   C09 vdW-DF functional   BH vdW-DF functional   VV vdW-DF functional    For a complete specification on input format please read the Siesta Manual (v 4.0 or greater). The DJMol, is currently equipped with a SIESTA 4.1 version (with OpenMP support) and a number of its pre - as well as post-processing tools.\nASE: Atomic Simulation Environment - is a Python based LGPL library which comprises a variety of post processing tools or methods. A general outline of ASE is following (block diagram courtesy: Dr. A H Larsen)\nFigure 1.2: Different modules in ASE. Interface denotes the DJMol platform.\nOne should note that to use ASE, a minimum-level knowledge on Python programming language (version 3.x) is a mandate. See Appendix-A for a basic course on Python programming. ASE’s input should written in an object-oriented style, so that the syntax of the input is highly flexible and it can be used to perform a series of jobs, by using, say, a for-loop. Another advantage is, it can be effectively coupled with other python base libraries such as NumPy, Matplotlib etc. to create different types of output files or data set.\nMost useful tasks with ASE are: structure optimization (with or without constraints), molecular dynamics, and performing nudged elastic band calculations or its variants. For more details see: https://wiki.fysik.dtu.dk/ase/ .\nOpenMD: it is an MD tool based on force-field type potential and it is widely used for performing MD simulations of open systems (such as liquids, proteins, nanoparticles, interfaces, and other complex systems). Note that we used 2.6 version of the program. The code is written in C++ and uses Python for its data pre/post processing. In the DJMol CygWin based C++ binaries are used and it is kept in ./OpenMD folder with other relevant parameter-files, Python scripts etc.\nThe OpenMD manual is accompanied with the DJMol and it is available at:\nhttp://openmd.org/wp-content/docs/OpenMD-2.6.pdf\nOpenMD uses a range of programs and Python scripts and a user must familiarize with its uses before the production calculation. Examples of OpenMD is illustrated in: http://openmd.org/category/examples/\nTable 5: Important binaries of OpenMD and its descriptions.\n   Binary Description     openmd.exe The Main OpenMD Executable for MD run.   atom2omd.exe atom2omd attempts to construct .omd files from files containing only atomic coordinate information   Dump2XYZ.exe Converts an OpenMD dump file into a file suitable for viewing in a molecular dynamics viewer.   DynamicProps.exe Computes time correlation functions like the velocity autocorrelation function, or the mean square displacement.   elasticConstants.exe elasticConstants computes the general elastic constants that relate stress and strain for a given input configuration.   Hydro.exe Hydro generates hydrodynamic resistance tensor (.hydro) files which are required when using the Langevin integrator using complex rigid bodies.   icosahedralBuilder.exe icosahedralBuilder creates single-component geometric solids that can be useful in simulating nanostructures.   nanoparticleBuilder.exe, nanorodBuilder.exe,nanorod_ programs to construct nanoparticles of various sizes and geometries.   omd2omd.exe omd2omd is a utility script which helps in replicating, rotating, and translating already built OpenMD .omd, .dump, and.eor files.   randomBuilder.exe, simpleBuilder.exe generate crystals.   recenter.exe recenter is a utility script which moves all integrable objects in an OpenMD file so that the center of mass is at the origin.   SequentialProps.exe Computes a time history of static properties from a dump file.   StaticProps.exe Computes static properties like the pair distribution function.   thermalizer.exe Thermalizer gives the atoms some initial velocities (at a given temperature) before the equilibration.    Table 4: Short Descriptions the Python scripts.\n   Python Scripts Descriptions     affineScale.py OpenMD affine scaling transform Takes an OpenMD file and scales both the periodic box and the coordinates of all StuntDoubles in the system by the same amount. You can either specify a new volume scaling for isotropic scaling, or specify one (or more) of the coordinates for non-isotropic scaling.   dumpConverter.py Dump File Converter Converts old-style OOPSE md and dump files into new OpenMD style combined files   funcflExtractor.py Funcfl Extractor Opens an DYNAMO86 EAM funcfl file, parses the data and writes out separate files for F[rho], rho(r), and Z(r)   hbtetAnalyzer.py It is used for doing analysis on Hydrogen Bond Tetrahedrality matrices   hydroExplainer.py Computes predicted diffusion constants and rotational relaxation times from a hydro file. Explains the values in the hydro file in terms of properties that can be calculated from a molecular dynamics simulation.   lcorrzFit.py A utility script to analyze of Legendre correlation functions   omdLast.py OpenMD File Extractor: Makes omd file from the last good frame of OpenMD dump file.   omdShrink.py OpenMD File Trimmer: Skips every n frames of an OpenMD dump file and loads it into new dump file   omd-solvator.py OMD Solvator: Opens two omd files, one with a solute structure and one with a solvent structure. Deletes any solvent molecules that overlap with solute molecules and produces a new combined omd file. The output omd file must be edited to run properly in OpenMD. Note that the two boxes must have identical box geometries (specified on the Hmat line).   omdSplit.py OpenMD File Splitter: Splits OpenMD dump file frames into separate omd files   pack2omd.py Packmol RigidBody Replacer: Finds atomistic rigid bodies in a packmol-generated xyz file and generates an OpenMD (omd) file with center of mass and orientational coordinates for rigid bodies.   principalAxisCalculator.py It opens an XYZ file and computes the moments of inertia and principal axes for the structure in the XYZ file. Optionally rotates the structure so that the long axis (that with the smallest eigenvalue) is pointing along the z-axis.   protonSampler.py This python script will generate proton disordered configurations of ice-Ih, given an input of the (.xyz) coordinates of the oxygen positions in the lattice.   slabBuilder.py SlabBuilder to create starting omd files for arbitrary surface cuts specified by Miller indices (hkl) of FCC, BCC and SC materials   slipLength.py slipLength is a built in analysis script which can compute the slip-length of a solid-liquid interface under shear. The script assumes the solid is placed in the middle of the box, with equal amounts of liquid on either side.   solLiqFricCalc.py Used for calculating solid liquid friction coefficients   solvator.py A script that reads in a water box and solute xyz (or pdb), merges the two systems, and deletes overlapping molecules   stat2dielectric.py A script that computes the static dielectric constant.   stat2dipolecorr.py A script that computes the system dipole correlation function   stat2tension.py Used for computing surface tensions from pressure tensors in stat files   stat2thcond.py Computes the correlation function of the heat flux vector that has been stored in a stat file. These can be used to compute the thermal conductivity.   stat2visco.py Computes various correlation functions of the pressure and pressure tensor that have been stored in a stat file. These can be used to compute shear and bulk viscosities.   vcorr2spectrum.py A script that processes a velocity autocorrelation function into a amplitude spectrum Post-processes a vcorr file and creates a normalized spectrum.   waterBoxer.py builds a lattice of water molecules in a periodic box   waterReplacer.py Finds atomistic waters in an xyz file and generates an OpenMD (omd) file with center of mass and orientational coordinates for rigid body waters.   waterRotator.py Samples water orientations from a list of known good orientations   wcorr2spectrum.py A script that processes a charge velocity autocorrelation function into a amplitude spectrum ;Post-processes a wcorr file and creates a normalized spectrum.    Major Components of the Software DJMol program is, in essence, a rich client platform (RCP) GUI application that has been built on the top of the RCP framework of the Netbeans IDE. The underlying OOP paradigm permits simple and straight-forward addition and extension of extra modules or plug-ins into its RCP frame work. This application can also be viewed as a molecular workbench that integrates many application programs for modeling molecular systems into a single framework. The main components of the GUI are discussed below.\n Basic IDE components: As indicated earlier the IDE component, inherited from Netbeans RCP module, is the core part the user-interface. The IDE framework offers a standard set of tools dedicated for advanced programming or scripting tasks. IDE significantly improve productivity of its users since it automates several text based processes (code completion, version control, project management, restoring old versions of the text files etc.). Several of native IDE menus are integrated; e.g. the File menu selects a coordinate data by its file extension (eg. xyz or hsd) to visualize the structure and open its text to the text editor of the IDE. Note that in the current version of the program xyz or hsd files are selected as the default file extensions for the viewer. The selected file can be manipulated at different levels by using its Edit, View and Source menus. Other basic IDE features like refactoring of files, Git facility, visual diff utility (to compare the contents of two text files) etc. are also supported. Project Explorer - which is placed on the far left side - shows the packages (directories and it files) that make up Python projects; It can also be used to systematically arrange or manipulate other data. Files and Favorite explorer panels are two tools for managing files (including binaries) in general. See Fig A for the IDE text editor which displays a Python script.  Figure 1.3: A Python script is displayed in the IDE text editor with syntax highlighting option.\nTop Component Window: The center panel of the software is set to display molecules and it embeds an unabridged Jmol visualizer binary and it is used in the TopComponent class (the basic unit of RCP display). Optionally a scripting tool (for Jmol scripting) can be invoked from this panel to create more sophisticated and customized molecular visualizations (See Table 5).  Table 5: Some selected one-liner commands of Jmol scripts and its descriptions.\n   Command Description     load=cod/1000373 {2,2,2} Loads 2x2x2 supercell of NaVO2F2 from COD database   minimize Molecular mechanics (UFF) steepest descent minimization   write \u0026quot;C:\\\\\\\\file.pdb\u0026quot; Save the molecule into a PDB file   isosurface cutoff 0.01 \u0026quot;C:\\\\\\\\cube.gz\u0026quot; Visualize an isosurface from a gzipped CUBE file   q=quaternion() Saving orientation in quaternion rather than Euler angles    2D and 3D Data Windows: JFreeChart library (a Java library for displaying various types of scientific data) is used to create a 2D graphs and it is usually projected onto a JPanel (a Swing GUI widget toolkit) to display the plots. By this, one can add more control options to the rendered graphs (See, Fig-D for a 2D plot with more control options). It is the default 2D data plot library of the DJMol and it has several graphic styles and it offers many configuration options to customize the rendering of graphics and it export the graphic content in PNG format. Apart from this, Matplotlib library is also used to display 2D graphics especially with Siesta add-on. The 3D graphics (scalar volumetric data such as density isosurface) windows all are embedded with Jmol application with some internal Jmol script commands. To manipulate the 3D data either Jmol scripts or Pythons scripts are used. For example, a Python script is used to convert xsf file format (which is frequently used in Siesta) into the cube format. Terminal Window: One can run OS commands and Python scripts with this window. Note that in the Windows version of the program the CygWin environment is automatically linked with this terminal. If necessary, WSL (a compatibility layer for running native Linux executables under Windows 10 OS) can also be linked. See the manual for more details. The plug-in for the Python integration into the software can be switched to get Python 2.x as well as Python 3.x. It gives the terminal based (interactive mode) access to the language. As an example, by using this terminal one can install many additional packages like ASE or Matplotlib library. Using SSH commands of CygWin or WSL this terminal can be connected with other remote machines. Console Window: This window is usually placed immediately below the Top Component window and it is mainly used to display console output text (eg. to show DFTB+ output when it runs). It also contains Start and Stop buttons to execute the DFTB+ program. The log text from this window can be saved or post processed, optionally. Add-on Windows: Other major window components are from the add-on programs based on Swing API. Currently there are six add-ons are constructed and all these programs are independent of each other. And these add-ons are built from JFrame – the base container of the application. At present it supports all the AWT (abstract window toolkit) components. Although more recent JavaFX class to create desktop applications exist in Java, we always used Swing based GUIs since more libraries and tools are available for Swing API.  Schematically all these key GUI components are shown in the figure 1.4 .\nFigure 1.4: A schematic classification of major window components which constitute the entire GUI of DJMol program.\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter2/","title":"Chaper 2","tags":[],"description":"","content":"Chapter 2: DFTB+ Calculations Here we illustrate some standard procedures that can be performed by the DFTB+ program in conjunction with DJMol platform. At present there are three distinct file types can be opened for DFTB+ calculations, viz., [1] dftb_in.hsd, \u0026lt;.xyz\u0026gt; and \u0026lt;.gen\u0026gt; files. The first one is the default unique file type for the program and the last two file extensions can be converted into \u0026lt;dftb_in.hsd\u0026gt; file by using a script writer (see below section).\n[1] DFTB+ Script Writer If one opens a \u0026lt;.xyz\u0026gt; or \u0026lt;.hsd\u0026gt; file, for visualizing the structure, subsequently one can also try to make a corresponding \u0026lt;dftb_in.hsd\u0026gt; file using a DFTB+ script writer program. Using this, a user can make a basic \u0026lt;dftb_in.hsd\u0026gt; script for a range of jobs, including, geometry optimization, calculating excited states or Hessian etc. It can be retrieved by:\nSet Up ➤ DFTB Scripting\nAnd the generated \u0026lt;dftb_in.hsd\u0026gt; file is kept in \u0026lt;Input\u0026gt; folder. Note that the atomic information including its geometry is directly taken from \u0026lt;gen\u0026gt; data of the currently loaded file.\nNote that, the Script-Writer module will write \u0026lt;TEMPdftb_in.hsd\u0026gt; into the \u0026lt;Input\u0026gt; folder. It is strongly recommended that, a user should always try to inspect/modify this script before its submission, if it is necessary.\nFigure 2.1: A screen shot of the script writer tool for the DFTB+ program.\n[2] Executing DFTB+ Scripts Running DFTB+ calculator is possible when you load a \u0026lt;dftb_in.hsd\u0026gt; file. Make sure that the \u0026lt;Input\u0026gt; folder should have this file before the execution and this file can be executed as:\nExecute ➤ Run DFTB+\nAnd if necessary, this Run can be killed by\nExecute ➤ Stop DFTB+\nThe generated/loaded files are usually placed in the` \u0026lt;DFTB_Scratch\u0026gt;filder. And these files are also sent back as a Zip file, to the directory where your current \u0026lt;hsd\u0026gt; file resides.\nDFTB+ generated data can be analyzed or visualized by the program. Main data analyzers are given below.\n[3] Force Components DFTB+ out file contains information about Cartesian force components (in atomic units) and this can be visualized as a line chart as shown below. The \u0026lt;detailed.out\u0026gt; file can be opened by:\nTools ➤ ForceComponents\nFigure 2.2: The x components of the Cartesian forces of the Fullerene molecule after the geometry optimization. The shaded portion can be easily zoomed in for more details.\n[4] Molecular Orbitals and Energy Levels MO information (including density and density difference files) are stored in the .CUBE format. In order to get cube files one needs to ensure that dftb_in.hsd file contains relevant keywords (WriteDetailedXML and WriteEigenvectors, see example directory for a template file). After running this file it will produce 3 out files (detailed.xml, charges.bin, and eigenvec.bin) and these files should be transferred from \u0026lt;DFTB_Scratch\u0026gt; directory to \u0026lt;ModesBinary\u0026gt; folder. Then invoke:\nExecute ➤ Run Waveplot\nFrom this window, select the proper SK file set (look at the combo box entitled, Specify SK set and Generate HSD file) and press on the button \u0026lt;Generate Waveplot File \u0026gt;. This will produce the needed HSD file for the Waveplot.exe binary file. View this file from the second tab and edit it if needed. Then invoke the \u0026lt;Calculate\u0026gt; button to produce the necessary CUBE file. Note that it might take some minutes to complete the task (depending on the size of the system).\nTo visualize the cubes file, first copy the Full Path of the folder, \u0026lt;ModesBinary\u0026gt; and then go to:\nTools ➤ View Cube\nThen click on the button, \u0026lt;Open Directory\u0026gt; and insert the recently copied Full Path into it and select a CUBE file. This will list all the CUBE files into the table, and this can be visualized easily by selecting the needed file name from the table and by clicking on the \u0026lt; Open\u0026gt; button. Optionally one can also use JMol scripting facility for more advanced file visualizations or manipulations.\nFigure 2.3: Visual of one of the MOs from the list of CUBE files.\nTo view only MO energy levels and its degeneracies, one can use the \u0026lt;detailed.out\u0026gt; file and this can be called by:\nTools ➤ MO Levels\nThe green lines represent occupied and red lines represent the un occupied levels. For accurate calculations (which use tight SCC parameters) one can also look at the degeneracies levels.\nFigure 2.4: MO energy levels from the detailed.out file.\n[5] UV-Visible Spectrum Convolution DFTB+ uses TD-DFTB for calculating oscillator strength of the optical excitations and this is stored in SPX.dat file. An add-on is used for reading this data and this can be invoked by:\nTools ➤ UV-Vis Spectrum\nSelect a SPX.dat file to proceed. This will plot the oscillator strengths (vertical red lines) and its fitted function ( broadened through convolution with a Gaussian, Lorentzian function or its linear combination, known as pseudo-Voigt functions - shown by blue curves). By default it uses eV however one can also obtain an equivalent spectrum using nm units (this creates a separate plot). Note that the oscillator strength is dimensionless quantity and it is described in the y axis.\nBy right clicking the plot, one can adjust several parameters (Auto Range, Zoom, Grid Lines, Axes properties etc.) of the figure and can save the image into PNG format.\nFigure 2.5: UV-Visible spectrum of an organic molecule fitted with Lorentzian convolution.\n[6] Partial Charges DFTB+ caclulates partial charges and this charges can be projected out into the individual atoms. This Utility can be invoked by:\nTools ➤ Partial Charges This utility read both the XYZ geometry and its corresponding detailed.out file. A color scale will also be shown for a reference. Note that this will generate a file and this file be saved for a reference (See Appendix section for the Saved Data).\nFigure 2.6: Numerical values of Mulliken\u0026rsquo;s partial charges are represented on atoms\n[7] Molecular Vibrations By using Harmonic approximation DFTB+ calculates the vibrational normal modes and frequencies. This requires Hessian Matrix (calculated by the DFTB+) and a script file for modes.exe binary (which calculates modes and frequencies).\nThe first step is to optimize the geometry. And once the optimized geometry is ready one can do the vibrational calculation with the necessary keywords (it includes Driver = SecondDerivatives{} keywords; See the example directory). This will generate the needed hessian.out file for the modes.exe.\nTo calculate vibrational modes vectors, to visualize/animate these modes and to get the frequencies, invoke the tool as:\nExecute ➤ Run Modes\nHere in this tool one has to enter the optimized GEN styled geometry\nGeometry= GenFormat {\n \u0026hellip;\n}\nand the hessian data as:\nhessian = {\n\u0026hellip;\n}\nNote that the dots (\u0026hellip;) represents the numerical value of the Hessian matrix ie. ALL the numerical value of the file , hessian.out, which is 3Nx3N matrix data (force constant matrix).\nAfter these two data entry select the corresponding SK file set and then click on the button: Generate Script. This will generate modes_in.hsd file in the ModesBinary folder. This file contains all the information for the modes.exe program which diagonalizes the hessian matrix to give modes/frequency information. The button, Generate Modes/Frequencies initiate this operation and produces the file, modes.xyz which contains the frequency/modes information.\nTo view this file another application is used this can be called by:\nTools ➤ View Modes\nThis will read the files modes.xyz and visualize the vectors/animations etc. Note that the Hessian data is used by the modes.exe binary as such. In other words it does not projects out translational and rotational motions. So that the user should be optimize the molecule well enough. If needed see http://gaussian.com/vib/ on the projection technique of Hessian matrix (Sayvetz conditions).\nFigure 2.7: Vibrational modes of water molecules read from the file modes.xyz in the ModesBinary directory.\n[8] Real Time Molecular Dynamics MD simulations can be done with or without using this tool. Normally one can submit MD job as usual (like a static calculation job). However, this MD tool is mainly used in real time so that a user can analyze Trajectory properties (Total Energy, Kinetic/Potential Energies, structure of each step) at Run Time. Moreover FFT based autocorrelation functions can be used to calculate IR spectra (from the dipole moments or from the velocity autocorrelation functions) after finishing the MD run. Note that, the MD analyzer tool should be invoked before the DFTB+ calculation. While running the MD calculation it will show\nthe progress of the data along with the current structure. Its step are:\n[1] Remove all the files from ./DFTB_Scratch directory. It is Mandate.\n[2] Open MD file as, File ➤ Open (hsd)\n[3] Invoke the MD tool as, Tools ➤ MD Analyzer\n[4] Execute MD run as, Execute ➤ Run DFTB+\n[5] Wait for the MD calculation to finish; and after that use tools like, \u0026lt;Velocity Autocorrelation Spectra\u0026gt;.\nFigure 2.8: Variations of energies during the MD, in real time.\n[9] Potential Energy Surfaces (2D/1D) The DJMol creates 2D PES (potential energy surface) by performing a series of DFTB+ calculations. For example, PES of H2O2 (hydrogen peroxide) molecule is created by doing a batch process. To create 2D PES we need two independent internal coordinate variables and, arbitrarily, we have chosen the O-O bond length and the H-H dihedral angle (in degrees) as shown in Fig. X.\nFigure 2.9: The two independent variables of H2O2 PES. The unit of bond length is in Angstrom and that of the dihedral angle is in degrees.\nIn first, make the structure of the molecule (or see Example folder for its coordinates); then using the \u0026lt;Convert Structure\u0026gt; tool (See Fig.2), convert this XYZ formatted file into the MOPIN format (which contains an equivalent z-matrix data). And copy the content of this file into \u0026lt;Build PES HSD\u0026gt; tool as shown in the Fig. 3.\nBy clicking the button, \u0026lt;Generate PES HSD Files\u0026gt;, this will generate 441 HSD input files for the DFTB+ program (it will take around ten minutes); copy all of these HSD files into the \u0026lt;SCRATCH\u0026gt; folder (a user can also select any other directory instead of this one) and then invoke the \u0026lt;Batch Processing Tool\u0026gt;. This will start DFTB+ program to execute all these files and create the PES in the \u0026lt;PESScan\u0026gt; folder.\n Figure 2.10: The Convert tool is used to transform Cartesian file into a Mopin file (which essentially contain the z-matrix in Mopac’s format).\n Figure 2.11: The converted MOPIN files content is inserted in the below text area and insert the variable name in the appropriate position. VariableI represents the O-O bond length (starts from 1.2Å) and VariableII, it H-H dihedral angle (starts with 0.0 o).\nAfter finishing the batch process, \u0026lt;PESViewer\u0026gt; can be invoked to get the plot of 2D PES or its contour diagram as shown in the Fig. 4. This utility will also indicates the minimum energy data point on the PES (in other words from this point one can start geometry optimization to locate local minimum) and its corresponding geometry file.\nIn \u0026lt;PESScan\u0026gt; folder one will see the following data files (See Table 6).\nTable 6: Datafiles of PES calculations.\n   Datafile Description     View2DPES.dat Gives the data intervals in x and y directions and energy as E(x,y) in eV   2DPESscan.dat It contains the sorted file names used in the PES creation with energy (in eV and in Hartree).    2DPESscanmovie.xyz Contains the geometry of the individual molecules in xyz format. It can be visualized/animated with DJMol. This can be userd to construct PES with other ab initio programs.     Figure 2.12: The PES of the cis-trans conversion of H2O2 . Note that the optimum bond length is around 1.48 Å and for shorter bond lengths the energy minimum is located near to 90.0o or 270.0 o.\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter3/","title":"Chaper 3","tags":[],"description":"","content":"Modeling with Siesta This add-on is mainly used for performing small to moderate level Siesta DFT calculations (with hundred of atoms). For larger calculations users are advised to use cluster/GCP machines with MPI parallel binaries. This add-on is equipped with OpenMP so that multi core machines can be used for its calculations, if it is found necessary. Note that Siesta 4.1 version is used in this add-on.\nAt the present version all molecular structural data and non Z-matrix styled crystalline FDF data is supported by this add-on.\n[1] Siesta Script Writer A basic Siesta script (.fdf file) write is written; it can be used to make a template FDF file for molecular as well as crystalline systems. Most commonly used key words are added and this can be selected optionally. However user is advised to refer Siesta 4.1 manual for finalizing the script. This tool can be invoked as:\nSet Up ➤ Siesta Scripting\nFigure 3.1: A script writer tool (FDF writer) in the Siesta add-on.\nThe newly generated file is kept in: .\\Input directory.\nIf an XYZ file is loaded into the Main Viewer, FDF file will generated with that geometry.\n[2] Siesta Add-On and Executing the Program All the basic tasks for Siesta (except its script writing) is carried out in Siesta add-on and it can be called by:\nExecute ➤ Siesta Calculator\nIt will launch the add-on as a separate program. A variety of FDF file is supported by the Jmol and hence this add-on. Use \u0026lt;Open\u0026gt; for calling these FDF files.\nFor example, h2o2.fdf can be opened and it can be submitted in this application, by simply going to the tab \u0026lt;Run\u0026gt; and clicking the Run button. The below figure shows a console output of a Siesta run. Note that the output file is stored in,\n.\\SiestaApp\\SiestaBinary.4.0.CygWin64 directory. And its console log file is saved in .\\SiestaApp\\siestaMAIN.log.\nFigure 3.2: Siesta log is shown in the console window of the add-on.\nIn \u0026lt;Analysis\u0026gt; some standard or routine calculations or analysis can be done, such as checking SCF convergence, Cartesian Force components and vectors (of optimized structure), Eigenvalues etc. from the relevant files in .\\SiestaApp\\SiestaBinary.4.0.CygWin64. See the below figure of h2o2.fdf out file examples.\n[3] Basic analayzers After running the calculations, one can use many basic analyzers, for example to check SCF convergence for single point as well as geometry optimization etc.\nFigure 3.3: The window shows basic commands for the Siesta post processing.\nSome of the analyzers results are shown below.\n Basic Analyzers Results:  Figure 3.4: Results from the Siesta post processing is shown.\nFigure 3.5: Force component vectors of each atom in H2O2 (non equilibrium geometry).\n Denchar Results  Denchar is a Siesta utility-program to plot charge densities and wave functions in real space. It can be used in 2D or in 3D. A template script for water molecule is given (but this can be modified very easily for other molecules), and its 2D/3D data can be obtained by following Steps I-IV, systematically. Note that Γ point used in this calculations.\n(a)\n(b)\nFigure 3.6: (a)Shows list of 2D data files of water molecule from the Denchar utility, with two different real wavefunctions (the first two low lying orbitals in a contour diagram);(b) shows equivalent 3D data.\nSimilary, band diagram can also be generates with template scripts.\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\nFigure 3.7: Band and DOS diagram of Aluminium (FCC). Note that in DOS plot, there are actually three lines (lower orange line is composed of two lines which corresponds to spin up and down contributions, whereas green line corresponds to the total DOS).\n[4] Wannier Orbitals and Band Diagrams To Wannier get localized molecular orbitals of crystalline or extended systems from the Bloch wavefunction, Wannier90.exe program is used in conjunction with the Siesta binaries. See www.wannier.org for more details.\nIn the tab \u0026lt;Wannier DOS/Orbitals\u0026gt; this information can be obtained by following steps I to VII (as an example template, FCC bulk Si is used). Results can be viewed by using \u0026lt;Plot Bands\u0026gt; or by \u0026lt;View Wannier Orbitals\u0026gt;. This template files can be easily modified for other systems.\nFigure 3.8: Steps of Wannier data calculations.\n\u0026lt;Plot Bands\u0026gt; give Wannier band diagram and \u0026lt;View Wannier Orbitals\u0026gt; list XSF files and that can be converted into the CUBE file format to display Wannier functions.\nFigure 3.9: A Wannier orbital of bulk Si generated from a XSF file.\n[5] Molecular Vibrations Molecular vibrations (using  point) can be easily calculated with the application. In the tab, \u0026lt;Vibrations\u0026gt;, execute the steps I-V, one after another (note that example script is made for water molecule, but it can be readily modified for other molecules.). The last command, \u0026lt;Run Vibra\u0026gt; calculates eigenvalues/vectors and it gives an another window in which different modes can be animated. The essential molecules vibrational data is saved in .\\SiestaApp\\SiestaBinary.4.0.CygWin64\\SiestaVibModes.xyz.\nFigure 3.10: A vibrational frequency calculator module and its mode-displayer.\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter4/","title":"Chaper 4","tags":[],"description":"","content":"OpenMD Simulations OpenMD add-on is aimed to perform MD calculations with OpenMD binary/scripts. This tool has four parts, (1), Viewer (2), Editor (3), Terminal and, (4), Utilities.\nFigure 4.1: Front end of the OpenMD add-on tool displays Ag nanoparticle obtained using OpenMD.\nIn viewer a normal XYZ file can be viewed (usually it is obtained from OMD dump file by using a converter, Dump2XYZ). All other standard Jmol view facilities are available here. Note that XYZ file will keep in the \u0026lt;OpenMD/Tempview\u0026gt; directory whereas the OMD file will be kept in the \u0026lt;./OpenMD\u0026gt; folder.\nThe Editor tool will open an OMD file. Since OMD file is a kind of XML file, a special editor is used to fold and un-fold many sections of this file as shown in the following file.\n In Terminal-Tab, simple DOS commands can be executed. Note that one should add:\ncmd.exe /c\nbefore the Python scripts (eg. cmd.exe /c python.exe slabBuilder.py). The commands are stored in a stack-array and it can be easily called back (See Stored Commands).\nIn the Utility-Tab several tools are added (eg. \u0026lt;Clean OpenMD\u0026gt; will delete the MD out files and \u0026lt;Open Trajectory\u0026gt; will open a separate viewer window to animate trajectories etc.). The \u0026lt;Plot Energies\u0026gt; will open \u0026lt;Stat\u0026gt; file and plot total, kinetic and potential energies. Similarly, \u0026lt;T P V\u0026gt; plot variation of temperature, pressure and volume during the MD run as it is stored in the \u0026lt;Stat\u0026gt; file.\nFigure 4.2: OpenMD Tool’s XML styled editor for the OMD scripts.\nFigure 4.3: OpenMD Analyze variation of different energies during an MD simulation.\nSince analyzing bond length gives an indication of reaction progress, \u0026lt;Calculate Bond Length\u0026gt; tool can be used to extract Bond length between two selected atoms (“Atom Number 1” and “Atom Number 2”). This will read XYZ file which doesn’t use Periodic Boundary Conditions or PBC (as an example see, SampleAnimationTest.xyz file).\nFigure 4.4: An out file from the MDAnalysis script. It describes that the bond is break near 400’th frame (in a periodic cubic box cell).\nHowever, if PBC is applied more advanced script is needed to extract this bond length information. For example, if the system is equipped with Python and MDAnalysis package, a user can:\n1. Edit \u0026lt;MDAnalysis\u0026gt; script (MDanalysisv1.py) if needed, eg. to change atom numbers\n2. Use \u0026lt;Add MDAnalysis in Terminal\u0026gt;, which will add cmd.exe /c python.exe MDanalysisv1.py in the Terminal window\n3. Go to Terminal and execute the above command.\nThe sample MDAnalysis script is:\nimport MDAnalysis as mda from MDAnalysis.analysis.distances import dist import matplotlib.pyplot as plt import numpy as np u = mda.Universe(\u0026#39;mdPBCTrajectoryTest.xyz\u0026#39;) mybox=np.array([16., 16., 16., 90., 90., 90.], dtype=\u0026#39;f\u0026#39;) # 1-2\u0026#39;th BL atoms in XYZ distances = [] for ts in u.trajectory: distances.append( dist( mda.AtomGroup([u.atoms[0]]), mda.AtomGroup([u.atoms[1]]), box=[16.,16., 16., 90, 90, 90] )[2][0] ) plt.switch_backend(\u0026#39;agg\u0026#39;) plt.plot(distances) plt.xlabel(\u0026#39;Frames\u0026#39;) plt.ylabel(\u0026#39;Bond Length (Å)\u0026#39;) plt.show() plt.savefig(\u0026#39;1-2.png\u0026#39;)  We strongly recommend to use MDAnalysis tools to post process the OpenMD data.\nThe details of MDAnalysis package is available at: https://www.mdanalysis.org/\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter5/","title":"Chaper 5","tags":[],"description":"","content":"Python scripting with ASE To demonstrate ASE scripting within the platform, we must create a Python project:\nFile ➤ New Project ➤ Python ➤ Python Project – Ant\nand save this in a suitable directory. We name the main class as \u0026lt;ASEdemo\u0026gt;.\nFigure 5.1: Setting up a Python ASE project in the DJMol application.\nFigure 5.2: A script window displays an ASE script.\nThe purpose of this ASE calculation is to obtain the phonon dispersion for bulk aluminum using a 7×7×7 supercell within effective medium theory (EMT as it is implemented in ASE). For the source, see, Ex2_phononbulkAl_DOS.py file from the example directory. After running it, this script will create the band and the DOS diagram of the system.\nThe script is provided in the Example directory. Once the script is ready, use \u0026lt;Run Project\u0026gt; command from the \u0026lt;Run\u0026gt; menu to execute the script. It will initiate ASE engine and produce the band and DOS diagrams. Optionally, users can develop their own python scripts in this project directory for other tasks (eg. to save the animation of a particular mode).\nRun ➤ Run Project\nFigure 5.3: (1) is the Workplace and (2) is the console output from the Python run and (3) is the resultant Band and DOS figures that is created in the Workplace.\nIn the next advanced example (see example directory of Python) we will show that RDF (radial distribution function) of melting copper in a cubic box. Here, EMT is also used but RDF function is taking from ASAP calculator. ASAP is a calculator for doing large-scale classical molecular dynamics within the ASE package (its libraries can be compiled in CygWin or WSL). Below figure shows the RDF from ASAP calculator and uses systems terminal.\nFigure 5.4: Radial distribution function of melting copper (FCC) at 2500K from an ASAP calculator.\nIn first add Terminal into the system by:\n Window ➤ IDE Tools ➤ Terminal\nThis will get CygWin ot WSL, depends upon the settings. After this, type the code in the terminal:\npython3.6m asedemo.py\nIt will launch an ASAP calculation, and calculates RDF of the melting copper atoms. Note that its RDF is very similar to that of water and it confirms that liquid state of Cu atoms at high temperature is well represented by the ASAP model.\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter6/","title":"Chaper 6","tags":[],"description":"","content":"Tools of DJMol Tools are generally calculator independent (add-on) modules which can assist some steps in the modeling.\nSome of the important Tools are described below.\n[1] Analysing Point Group DJMol use a point group analyzer and from this one can easily find the point group of a molecule and its subgroups. It can also tell the next possible point group within a specified error-bar. This module can be invoked by:\nTools ➤ PointGroup Analyzer\nThis tool can also be used to deform the geometry of molecules so that one can modify a molecule’s PG into another one (in other words, we can constrain a PG into its sub group).\n[2] Z-Matrix Editor  Z-Matrix or Z-mat tool can be called by:\nExtra ➤ Z-Matrix Tool\nThis Z-Mat editor is made for the XYZ files; It can be either used as an independent program (use File button to load a required XYZ file) or as an auxiliary program to manipulate the loaded XYZ file. Use either \u0026lt;New File\u0026gt; button to vary Z-matrix a of a new Cartesian file or \u0026lt;Current File\u0026gt; button to fetch the currently loaded geometry from the main panel of DJmol.\nFigure 6.1: A butane molecule (exaggerated) and its Z-matrix data.\nTo change Z-Mat Data:\nAfter displaying the geometry, select \u0026lt;Select a Z-mat variable\u0026gt; radio button to show the corresponding Z-matrix data (MOPAC style, generated from the OpenBabel application) of the displayed molecule in this application.\n Also select any single cell from either \u0026lt;X\u0026gt;, or \u0026lt;Y\u0026gt; or \u0026lt;Z\u0026gt; column, which represents bond-length, bond angles, or dihedral angles, respectively. After that select \u0026lt;Insert Variable\u0026gt; button to make the cell element as a Z-mat variable.\nAnd then use the \u0026lt;Save\u0026gt; button and close the window. After that, immediately select the \u0026lt;Start Zmatrix Variation\u0026gt; menu from the top of the window, and by using [+] and [-] buttons, start the variation.\nOne can either save the data (\u0026lt;Update Zmat\u0026gt; button) or discard the variation and to move the molecule into its original state by using \u0026lt;Undo Update\u0026gt; button.\nIt is also important to note that to stop and undo the current variation,first to select \u0026lt;Stop Variations\u0026gt; and press \u0026lt;Undo Update\u0026gt; button\u0026gt;.\nIf you want to move only X or Y or Z positions of a single atom use the menu ( \u0026lt;Move selected Atom\u0026gt; ), and select an atom (use a click on the desired atom) , and press any[x+][x-]\u0026hellip;buttons near the bottom left corner.\nImportant: To save the updated Geometry press \u0026lt;Update Zmat\u0026gt; AND then \u0026lt;Save Structure\u0026gt; button.\nOr to discard the variation and to move the molecule into its original state by using \u0026lt;Undo Update\u0026gt; button.\nAlso don\u0026rsquo;t forget to use \u0026lt;Save Structure\u0026gt; button to save the modified Cartesian file. It will be saved as CurrentFinalXYZ.xyz file in the folder \u0026lt; ZMATfolder\u0026gt; in the program directory.\nIf necessary use:\n[ 1 ] \u0026lt;Select Atoms Labels\u0026gt; to see individual atom labels, which may be useful when one manipulates Z-Mat.\n[ 2 ] \u0026lt;Show initial bonds\u0026gt; for keeping the original bonding pattern, irrespective of the current geometric state. This can be useful when some bonds are too far away from the initial bonded state.\n[ 3 ] \u0026lt;Show axis\u0026gt; to show cartesian axis\n[ 4 ] \u0026lt;Add New Bond\u0026gt;[n1] [n2] - to show a new bond between the atomlabel, n1 to atomlabel2, n2 atoms.\n[ 5 ] \u0026lt;Builder\u0026gt; option can be used if necessary.\nNote that a user can also enter numerical values (in float) to the Text Fields. Also Move the slide bar to maximum when you vary the Angles/Dihedral angles and to a minimum if you want to manipulate the distance.\n[3] Remote Submission of Scripts For time consuming job, such as MD calculations, it is a better idea to use a dedicated machine like Linux cluster/Google Cloud etc. instead of a PC. In this case, one need to generate SSH keys (ie. one private and one public key), preferably, by using PUTTYGEN application; see Puttygen to download this mandate application.\nNote that we need \u0026lt;RSA\u0026gt; based private key (which is stored in your PC) and a public key (stored in the Remote machine). Note that you must enter a \u0026lt;Passphrase\u0026gt; for the \u0026lt;Private key\u0026gt; and its format should be in the OpenSSH (ie. not in the PPK format, which is the PuttyGens' default). PuttyGEN can convert this private key in PPK format to OpenSSH format. Finally the Private Key should be kept in the \u0026lt;ssh\u0026gt; folder with a file name, \u0026lt;id_rsa\u0026gt;. Make sure that the file \u0026lt;known_hosts\u0026gt; is existed in \u0026lt;ssh\u0026gt; format. After this one can invoke the \u0026lt;Remote Submission Tool\u0026gt; as:\nRunProject ➤ Remote Submission\nThis tool can be used instead of PUTTY, and it is equipped with tools for file upload/download purposes. The downloaded files are kept in \u0026lt;SCP\u0026gt; folder, by default.\n Figure 6.2: A sample SSH session (for Google Cloud Platform remote connection and file transactions).\n[4] Version Control using GIT Version control (VC) systems are a category of software tools that help a software team manage changes to source code over time. Version control software keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members. Git is an example of VCS.\nWhy the VC is used in the DJMol? Since the text based input scripts are playing an important role in the modeling (inputs of Siesta/DFTB/ASE, all are text files). Using VC, these data can be re-edited remotely and at the same time it keeps different version of these files in a systematic way (for example, later, it can be used by collaborators/public).\nSome Basic Definitions to be familiarized are:\n​1. FETCH: The git fetch command downloads commits, files, and refs from a remote repository into your local repo. Fetching is what you do when you want to see what everybody else has been working on.\n​2. PULL: The git pull command is used to fetch and download content from a remote repository and immediately update the local repository to match that content.\n​3. PUSH: The git push command is used to upload local repository content to a remote repository. Pushing is how you transfer commits from your local repository to a remote repo. It is the counterparts to git fetch.\nHow to use Git to push and pull in DJMol?\n​1. Initializing Version Control.\n​a. Set up a Git Remote Repository in GitHub and copy the Repository URL.\n​b. Open the project in which you need to use version Control.\n​c. Initializing the Local Repository.\nTeam ➤ Git ➤ Initialize ➤ (OK)\n​d. Linking the Local Repository and the online Repository\nTeam ➤ Remote ➤ Pull ➤ Fill ➤ Check Master ➤ Finish\nSpecify ➤ PateTheRepository ➤ UserName/PassWord (if needed) ➤ Next\n 2. Push\n​a. After making necessary changes in the Project.\n​b. From the Project sidebar, add the needed files to the repository by right-clicking on the file and Clicking on Add.\n​c. Commit the files to the Repository\nTeam ➤ Commit ➤ AddACommitMessage ➤ Commit\n​d. Push to remote repository.\nTeam ➤ Remote ➤ PushToUpstream ➤ Yes\n​3. Pull\n​a. Fetch\nTeam ➤ Remote ➤ Fetch ➤ Next ➤ Finish\n​b. Pull\nTeam ➤ Remote ➤ Pull ➤ Next ➤ CheckMaster ➤ Finish\nInstallation of Git\nAdding Github Plugins\nAfter installing the application, search \u0026lt;Git\u0026gt; in the plug-ins search field. Select the \u0026lt;Git\u0026gt; from the \u0026lt;Installed Packages\u0026gt; and click on \u0026lt;Activate\u0026gt; as shown below figure.\nFigure 6.3: Installation of Github plugin in DJMol.\n[5] Database File Retrieving To fetch different structural file form various open file repositories, a Database tool is implemented. It is essentially uses Jmol’s DB module.\nIt can be launched by:\nExtra ➤ Database Tool\nOpen URL: It can be used to open XYZ or PDB file or any other Jmol recognizable file from the web server, say from Github. Open MOL: It is mainly for, SMILES, InChI, or CAS from either a PubChem database or from NCI/NIH database.\nOpen PDB: It use RCSB web (please prefer RCSB) to load 4-character PDB ID (eg. 1crn) or 3 -character ligand (eg. 60C).\nOpen COD: It opens a specific COD ID from http://www.crystallography.net/cod/ Open Materials Project: It opens a specific Materials Project ID number:\nAll opened file is saved in ./Database folder from Export To: Only MOL, XYZ and PDB formats are supported for export its images.\nFigure 6.4: Showing a Database window with a retrieved COD file from COD databse.\n[6] Miscellaneous Tools Some of the miscellaneous tools are shown below:\nStart Batch Process: For DFTB+ calculation, a number of HSD files in a particular folder can be called one after another (known as batch processing). This will be useful for building 1D PES or to analyze energies of particular set of molecules. The resultant TGZ files contain all the out files including the submitted HSD file, and it will be transformed to the folder at the end of the each calculation.\nCalculator: System’s default calculator can be invoked.\nGIF Utility: GIF animation files can be viewed or generated using this utility (eg. phonon modes). Time between two frames can be adjusted and the resultant file is stored in ./Scratch_images.\nProcess Status: It is used to monitor current resources of the computer system (used/availble RAM, HDD space etc.). This can be used before starting a calculation. For example, if the PC memory is low, allocate more RAM by stopping other less important process by using Window’s Task Manager utility.\nUnit Conversion: A basic unit converter for length, time, energy etc. it also includes atomic unit.\nMatrix Viewer: 2D matrix data viewer of the program. It is useful to analyze the overall shape and symmetry of the matrix data, such as Hessian or Hamiltonian. See example directory for its sample file.\nConvert Structure: Open Babel is used to convert from one structure data into another data. See Figure 2.10.\nStandard Orientation: Using symmetry a disoriented molecule can be oriented with respect to a symmetry axis. This tool is useful for making a more systematic Z-matrix or Cartesian file . It is strongly recommended that the standard oriented geometry data should be used in the Z-matrix tool to re-adjust its coordinates. Open DJMol Directory: It will open the parent directory.\nSend Message: User can mail the forum using this utility. Please academic E-mail ID (avoid .com E-mail IDs – it won’t support). If needed images should be linked as an URL link (say, by drive.google.com/… link).\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter7/","title":"Chaper 7","tags":[],"description":"","content":"Architecture of the Program Software Architecture\nIn practice, computational materials science research encompasses three distinctive steps, viz. (1), constructing the geometrical data or structure of the system (2), performing computations and, (3), obtaining results by the post processing of calculated data. All these steps can be effectively coupled by means of modeling platform such that a user can create, visualize, and share various input data files and run it with appropriate programs to obtain output data to analyze the results.\nBy integrating molecular (or crystal) visualizer, scripting tools (in this case, Python and Jmol scripting) and other standard features of an IDE (integrated development environment), a user can interactively build or manipulate structures of materials or molecules, and its atomistic properties can be calculated with appropriate ab initio programs from either a local or a remote machine. A number of built-in tools, scripts are provided for the analysis purpose. To demonstrate the platform we have used DFTB+ as well as Siesta electronic structure code along with ASE (atomic simulation environment) and OpenMD molecular dynamics package.\n The programming language, Java (version 8) was chosen for this project since it is free, strongly object-oriented and shows its neutrality to the various operating systems. The object oriented programming is arguably the most popular software development technique which effectively manages the complexity in code development [9]. We preferred Java, since (1) it does not use pointers, and (2), it supports threads implicitly. Although pointers provide direct access to the computer memory, careless use of the pointers will easily leads to segmentation fault and other vulnerables. It is our personal opinion that the bugs emerged from the improper application of pointers are difficult to trace or debug, in addition to this, code with pointers is difficult to translate into other computer languages without the pointer features. Concerning threads, in this application, we used a number of threads (i.e. user threads), apart from the JVM generated daemon threads. Since the threads are inherently supported by the language one can readily create a thread by extending a Thread class. Exception handling of Java is equipped with two types, namely, unchecked and checked exception handling. And in most of the cases we used checked exceptions, as it is less tedious to implement.\n The core of the DJMol application consists of (Apache-) Netbeans Platform and it can be regarded as the engine behind the Netbeans IDE. In other words, many of the technical features of DJMol program is inherited from Netbeans IDE which is initially designed for developing Java/Javascript and C/C++ applications and consists a number of utilities to increase the productivity of a user (for example, it has an advanced sourcecode editor with code completion utilities, tools for refactoring, version control systems, Git based collaboration tools etc.) and these utilities can also be used efficiently for various modeling or scripting tasks. Moreover, this platform consists of a set of independent modular software components called modules (e.g., an SSH module to communicate with an external cloud platform). Apart from this, the program supports plug-ins so that one can selectively add or remove new features into it (e.g. Python interpreter) without being re-compiled the code. Optionally, users of the code can make their own plug-ins, for example, to incorporate another ab initio package. See the below for the schematic structure of the program. To the best of our knowledge, DJMol is the first opensource modeling platform which is built from a programming IDE.\nTo display the molecular, crystal, nanostructures a Java library, Jmol, has been embedded into the program. The Jmol program is an open source, cross-platform and a highly independent (i.e. it does not depend on any third party libraries like Java3D or OpenGL) 3D visualization application. Apart from this, there are two distinct features associated with Jmol: (1) Jmol can be programmatically embedded into any Java code which uses Swing application programming interface (2), It supports an internal command scripting, so that a user can control or manipulate the display or send and retrieve parameters, data, commands etc. For example, to manipulate Gaussian cube files a user can effectively apply this internal scripting ability of Jmol. Unlike most of the visualizers, Jmol is capable of perceiving the molecular structure in three dimensions by applying stereographic projections. A viewer, with appropriate anaglyph spectacles, 3D perspective images of the molecules can be interactively visualized. Apart from this, Jmol consists of an UFF (uniform force field) method and it can be used to pre-optimize a variety of organic as well as inorganic molecules. To create 2D data plots we have used either Matplotlib based scripts or Jfreechart libraries. In the case of 3D data plots, (for example, the potential energy surfaces or orbital contour diagrams), a Java based opensource library jzy3d has been used.\nFigure 7.1: A schematic diagram of DJMol software architecture. The core of the program is an IDE which is connected to other modules or programs.\nFigure 7.2: A standard workflow for a modeling task under the DJMol program (mandate workflows are indicated by black arrows).\nJava’s native thread is used to initiate add-ons so that its console can be controlled independently, if needed. Below figure shows Windos’ Task managers snapshot of OpenMD add-on, while it is under running (and it indicate two independent processes).\n"},{"uri":"https://djmolprogram.github.io/documentation/chapter8/","title":"Chaper 8","tags":[],"description":"","content":"Software Applications Demonstration of DJMol - 1\nUV-Visible Spectrum of Silver Nanocluster using DFTB+\nTo demonstrate the basic functionality of the software, here we describe how an UV-Visible spectrum of a silver nanocluster can be calculated using DFTB+ code in conjunction with the DJMol software. There are three steps to calculate the spectrum, viz. (1) Obtain the structure of Ag nanocluster, (2) Optimize the structure and create the corresponding HSD file for the TD-DFTB calculation and, (3) Plot the convoluted Spectrum data. Note that we arbitrarily choose Ag 177 nanocluster (its diameter is around 1.5 nm) for the TD-DFTB calculation. And the geometry of this cluster is generated by OpenMD package (in CygWin environment) by using experimental lattice constant of silver (4.08 A) and FCC lattice structure. The following commands are used in the DJMol terminal to obtain the Cartesian coordinate data of the system:\ncmd.exe /c nanoparticleBuilder --latticeConstant=4.08 --radius=15 Ag.omd -o NP15.omd\ncmd.exe /c Dump2XYZ -i NP15.omd\nThe resultant coordinate data (XYZ file), can be visualized by DJMol program to generate a dftb_in.hsd file using the DFTB+ Script Writer tool with appropriate settings, for example, by adding a conjugate gradient method. See SetUp menu for this utility. This HSD file can be then used to generate an optimized Ag 177 cluster by executing a DFTB+ calculation. It can be seen that this optimized cluster (See geo_end.xyz file for the data) is approximately spherical in symmetry. The optimized structure was again visualized and used in the Script Writer tool to make another HSD file to include instructions for Casida method (a TD-DFTB algorithm). The essential part of this script is:\nExcitedState = Casida { NrOfExcitations=100 StateOfInterest=0 Symmetry=singlet WriteTransitions=no WriteSPTransitions=yes WriteMulliken=no WriteCoefficients=no WriteEigenvectors=no WriteTransitionDipole=no OscillatorWindow=0.01 } In all the DFTB calculation, we used hyb-0-2 parameter set is used for the silver atoms. This newly generated HSD file is submitted to a remote Linux machine using the SSH utility (See Extra menu in the tool bar) of the DJMol and after finishing the calculation a SPX output file was retrieved in the local machine, which contains the oscillator strengths of different electronic excitations. It was then plotted with UV-Vis spectrum from the Tool menu to obtain the spectrum of the molecule. A Lorentzian convolution (with 0.035 eV of full width at half maximum) is used to obtain the spectrum as shown in the Fig.X. Note that the absorption maximum wavelength (λmax) is located around 440 nm i.e. around the indigo-blue region. By plotting molecular orbital energy levels (using MOLevels tool and with the detailed.out file) one can seen that the Fermi level is near to 3.9 eV and band gap of this cluster is negligibly small (See the inset figure in Fig. X). And it qualitatively indicates that Ag177 behaves like a semi-metal.\nDifferent sized nanoparticles can be constructed by applying the above said method to study red shift property of the system. See the Fig.XX. Experimentally this is a known fact for the Ag n system (By comparing λmax values of clusters, we can seen that, λ max shifts towards UV region if we increase the size of the nano clusters.). This can be qualitatively justified by particle in a box analogy. Note that the diameter of Ag 177 is longer than that of the Ag13 so that its electron can move longer along its diameter (the box length). This will reduce its ΔE values significantly (by increasing the size of the diameter of a silver cluster, a photon from the red region - a wavelength that corresponds to a lower energy - can cause an electronic excitation). For experimental UV-Vis spectra, see: https://www.sigmaaldrich.com/technical-documents/articles/materials-science/nanomaterials/silver-nanoparticles.html.\nFigure 8.1: The UV-Visible spectrum of Ag177 nanocluster as it is plotted with the UV-Vis Spectrum tool. The vertical red line shows the oscillator strengths of electronic transitions. The inset figure shows HOMOs (green lines) and LUMOs (red lines) of the system.\nFigure 8.2: Sizes of different AG-nanoparticle and its UV-Vis spectrum. Note the red shift of\nDemonstration of DJMol - 2\nFrontier Orbitals of C60 Calculated with Siesta\nVolumetric MO data can be made by using executing steps described in Denchar Utility, systematically using the Siesta add-on. The Siesta add-on can be invoked by: Execute ➤ Siesta Calculator\nIn this section we shall obtain the frontier orbitals of Buckminster fullerene. See the example file Fullerene.fdf under the Siesta_Samples folder for its coordinate (note that it is an un-optimized structure; its optimization procedure is left to the user as an additional exercise). Since we used a molecular system in a unit cell, the default k-point ( Γ-point) is used to represent electronic wavefunction coefficients. Note that HOMO and LUMO coefficients are at 120 and 121’th k-points. See the Siesta Manual for more details.\nAnd change the main setting of the fdf file as (ie. except the coordinate as it is inserted between, AtomicCoordinatesAndAtomSpecies block):\n| #------------------------------------------------ | # IMPORTANT: DO NOT CHANGE SystemLabel #------------------------------------------------ SystemName Fullerene molecule # Descriptive name of the system SystemLabel siesta # Short name for naming files NumberOfAtoms 60 NumberOfSpecies 1 SpinPolarized T WriteDenchar T WriteWaveFunctions T COOP.Write T %block WaveFuncKpoints 0.000 0.000 0.000 from 120 to 121 # Gamma wavefuncs Here, 120 = HOMO %endblock WaveFuncKPoints %block ChemicalSpeciesLabel 1 6 C # SpeciesIndex,AtomicNumber,SpeciesLabel %endblock ChemicalSpeciesLabel LatticeConstant 25.0 Ang %block LatticeVectors 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 %endblock LatticeVectors AtomicCoordinatesFormat Ang # Format for coordinates %block AtomicCoordinatesAndAtomicSpecies . . . %endblock AtomicCoordinatesAndAtomicSpecies WriteEigenvalues T #################################### ################### # For the following parameters, default value is ok. MeshCutoff 100. Ry # Mesh cutoff. real space mesh (Ry) PAO.BasisType split # Type of PAO basis set PAO.EnergyShift 50 meV PAO.BasisSize DZ # with polarization # SCF options MaxSCFIterations 60 # Maximum number of SCF iter DM.MixingWeight 0.1 # New DM amount for next SCF cycle DM.Tolerance 1.d-4 # Tolerance in maximum difference # between input and output DM DM.NumberPulay 3 DM.UseSaveDM F # to use continuation files MD.USeSaveXV F NeglNonOverlapInt false # Neglect non-overlap interactions SolutionMethod diagon # OrderN or Diagon ElectronicTemperature 6 K # Temp. for Fermi smearing (Ry) XC.Functional GGA XC.Authors PBE From this we can seen that, a double zeta type basis is used along with the PBE functional for the DFT calculation. A cubic box of 25 Å lengths is used to place the molecule.\nRun the calculation as usual and after finishing the run, plot MO energy levels, using MO Energies, which also indicate the level of HOMO (from the first occupied level, which is level 1):\nThen using, Edit denchar3D.fdf option insert the below text therein, and execute its next step, which is Run Denchar. After finishing View 2D/3D Files buttons can be clicked to view orbitals. Please see the next figures for the MOs of HOMO and LUMO (MO level, 120 and 121, respectively).\n#------------------------------------------------ # Note: It is a Sample Script only # You have to Modify this according # to your system/requirement # See the Manual for more details #------------------------------------------------ Denchar.TypeOfRun 3D Denchar.PlotCharge T # If .true. SystemLabel.DM must be present Denchar.PlotWaveFunctions T # If .true. SystemLabel.WFSX must be present Denchar.CoorUnits Ang Denchar.DensityUnits Ele/Ang**3 # set the mesh for wavefunction plot Denchar.NumberPointsX 100 Denchar.NumberPointsY 100 Denchar.NumberPointsZ 100 Denchar.MinX -12.5 Ang Denchar.MaxX 12.5 Ang Denchar.MinY -12.5 Ang Denchar.MaxY 12.5 Ang Denchar.MinZ -12.5 Ang Denchar.MaxZ 12.5 Ang %block ChemicalSpeciesLabel 1 6 C # Species index, atomic number, species label %endblock ChemicalSpeciesLabel Figure 8.3: Using Γ-point Siesta’s SCF calculations yields MO coefficients. Here 120’th wavefunction at the Γ-point (alias MO-120) is HOMO (upper figure) and MO-121 is LUMO. The qualities can be adjusted with Denchar parameter settings.\nDemonstration of DJMol - 3\nOpenMD MD simulation of Gold-nanoparticle\nIn this demonstration, we would obtain the gold-gold atom pair distribution function from the OpenMD molecular dynamics trajectory. One can open OpenMD tool by:\nExecute ➤ OpenMD Tool\nIn first we have to construct a Au-nanoparticle (with icosahedron symmetry). A basic starting script for the calculation is given below (its file name is gold.omd, and note HTML styled tags in it)\n\\\u0026lt;OpenMD\\\u0026gt; \\\u0026lt;MetaData\\\u0026gt; molecule{ name = \u0026quot;Au\u0026quot;; atom[0]{ type = \u0026quot;Au\u0026quot;; position(0.0, 0.0, 0.0); } } component{ type = \u0026quot;Au\u0026quot;; nMol = 1; } forceField = \u0026quot;SC\u0026quot;; forceFieldFileName = \u0026quot;SuttonChen.QSC.frc\u0026quot;; \\\u0026lt;/MetaData\\\u0026gt; \\\u0026lt;/OpenMD\\\u0026gt; Using the command (in the OpenMD tool’s command shell window) save the file, gold.omd ,with the above data.\ncmd.exe /c notepad.exe gold.omd\nThen run the following commands one after another:\ncmd.exe /c .\\\\icosahedralBuilder.exe -o file.omd --shell=8 --latticeConstant=4.08 --ico gold.omd\ncmd.exe /c Dump2XYZ -i file.omd\ncmd.exe /c more file.xyz\nIf everything is correct you will get a gold-nanoparticle structure as shown in the below figure-a. The above procedure construct a file called, file.omd which contains all the XYZ data of the nanoparticle.\nHowever in order to start an MD run, we need initial velocities. For the purpose please run the command:\ncmd.exe /c .\\\\thermalizer -t 5 -o file-5K.omd file.omd\nIt will create a new file, file-5K.omd with new initial velovities and 5 Kelvin as its target temperature. Its main parameters are:\nforceField = \u0026quot;SC\u0026quot;; forceFieldFileName = \u0026quot;SuttonChen.QSC.frc\u0026quot;; ensemble = \u0026quot;LHull\u0026quot;; targetTemp = 5; targetPressure = 1; viscosity = 0.1; dt = 2.0; runTime = 2E5; sampleTime = 500.0; statusTime = 4; seed = 985456376; usePeriodicBoundaryConditions = \u0026quot;false\u0026quot;; tauThermostat = 1E3; tauBarostat = 5E3; Then run the actual OpenMD molecular dynamics run as,\ncmd.exe /c openmd file-5K.omd\nThis may take a while (2 hour), and its trajectory information will stored in the dump file. From this MD animation can be retrived as:\ncmd.exe /c Dump2XYZ -b -i file-5K.dump\nMoreover, from the below figure one can see that the 5K thermalization is achieved in the MD run (note its convergence to 5K)\nAfter that, a script utility to retrieve, gAu-Au((r), as:\ncmd.exe /c StaticProps.exe -i file-5K.dump --gofr --sele1=\u0026quot;select Au*\u0026quot; --sele2=\u0026quot;select Au*\u0026quot;\nFigure 8.4: Pair correlation function (g(r)) obtained from the MD trajectory data which use only test-level parameters. Note the similarity with g(r) obtained by a hard-sphere model (inset figure courtesy, J. Nanopart. Res, 13, 4277 (2011).)\nFigure 8.5: The initial (top) and final (bottom) snapshot of the MD run. Note that the system’s initial temperature was 0K and it was equilibrated to 5K during the MD run.\nDemonstration of DJMol - 4\nASE simulation of an adatom diffusion\nHere we use ASE to obtain the energy profile of a physical process - diffusion of an adatom or adsorbed atom (Au) on the top of a metallic surface of Al atoms. Nudged elastic band (NEB) method is used for the calculation, in which an initial structure (where an adatom i.e. gold atom is placed in the left side) and a final structure (adatom is placed in the right side) of the process is used as its input data. For more details please visit ASE tutorial web page. Note that we used EMT calculators (it is a really fast albeit highly approximated potential function) for this calculation however one can use Siesta within ASE to obtain more realistic diffusion barrier.\nRefer Chapter-5 for creating a Python Project. Then add an Empty module (InitialFinalStructure.py fie) into the src directory. Then add the following Python source into it:\nfrom ase.build import fcc100, add_adsorbate from ase.constraints import FixAtoms from ase.calculators.emt import EMT from ase.optimize import QuasiNewton # 3x3-Al(001) surface with 3 layers and an  # Au atom adsorbed in a hollow site:  slab = fcc100(\u0026#39;Al\u0026#39;, size=(3, 3, 3)) add_adsorbate(slab, \u0026#39;Au\u0026#39;, 1.7, \u0026#39;hollow\u0026#39;) slab.center(axis=2, vacuum=4.0) # Fix second and third layers:  mask = [atom.tag \u0026gt; 1 for atom in slab] slab.set_constraint(FixAtoms(mask=mask)) # Use EMT potential:  slab.calc = EMT() # Initial state:  qn = QuasiNewton(slab, trajectory=\u0026#39;initial.traj\u0026#39;) qn.run(fmax=0.05) # Final state:  slab[-1].x += slab.get_cell()[0, 0] / 3 qn = QuasiNewton(slab, trajectory=\u0026#39;final.traj\u0026#39;) qn.run(fmax=0.05) Then Run the file (Run ► Run File). This will create, initial.traj and final.traj files which contains the initial and final structure respectively.\nAfter this, the NEB calculation can be started (don’t forget to create a new Python file for this) and its Python source is given below:\n# To change this license header, choose License Headers in Project Properties. # To change this template file, choose Tools | Templates  # and open the template in the editor.  from ase.io import read from ase.constraints import FixAtoms from ase.calculators.emt import EMT from ase.neb import NEB from ase.optimize import BFGS initial = read(\u0026#39;initial.traj\u0026#39;) final = read(\u0026#39;final.traj\u0026#39;) constraint = FixAtoms(mask=[atom.tag \u0026gt; 1 for atom in initial]) images = [initial] for i in range(9): image = initial.copy() image.calc = EMT() image.set_constraint(constraint) images.append(image) images.append(final) neb = NEB(images) neb.interpolate() qn = BFGS(neb, trajectory=\u0026#39;neb.traj\u0026#39;) qn.run(fmax=0.05) The energy profile can be saved in a PNG image by using the following script:\nimport matplotlib.pyplot as plt from ase.neb import NEBTools from ase.io import read images = read(\u0026#39;neb.traj@-11:\u0026#39;) nebtools = NEBTools(images) # Get the calculated barrier and the energy change of the reaction. Ef, dE = nebtools.get_barrier() # Get the barrier without any interpolation between highest images. Ef, dE = nebtools.get_barrier(fit=False) # Get the actual maximum force at this point in the simulation.  max_force = nebtools.get_fmax() # Create a figure like that coming from ASE-GUI.  fig = nebtools.plot_band() fig.savefig(\u0026#39;diffusion-barrier.png\u0026#39;) # Create a figure with custom parameters.  fig = plt.figure(figsize=(5.5, 4.0)) ax = fig.add_axes((0.15, 0.15, 0.8, 0.75)) nebtools.plot_band(ax) fig.savefig(\u0026#39;diffusion-barrier.png\u0026#39;) Finally, the neb.traj file, which contains the entire geometry of the process in binary format, is then used to obtain XYZ format by the following script:\nimport matplotlib.pyplot as plt from ase.calculators.emt import EMT from ase.neb import NEB from ase.optimize import BFGS from ase.io import read, write import os # read the last structures (of 5 images used in NEB) images = read(\u0026#39;neb.traj@-11:\u0026#39;) for i in range(0, len(images)): atoms = images[i] #print(atoms.get_positions())  write(\u0026#39;delete.xyz\u0026#39;, atoms) inFile = open(os.path.join( \u0026#39;delete.xyz\u0026#39;), \u0026#39;r\u0026#39;) fileStr = inFile.read() outFile = open(\u0026#34;neb_movie.xyz\u0026#34;, \u0026#39;a\u0026#39;) outFile.write(fileStr) # @type outFile  outFile.close() inFile.close() Additionally, using DJMol\u0026rsquo;s xyz File loader (File►Open Structure) the geometries of the process as it is saved in \u0026ldquo;neb_movie.xyz\u0026rdquo; can be displayed or animated (See the below figure).\nFigure 8.6: Diffusion of gold atom over the aluminium surface (FCC) from one hollow site to another, in different perspectives; Nine NEB images were used for this NEB profile.\nFigure 8.7: Starting (I) and ending (F) geometries of the Diffusion of gold atom; The diffusion barrier (around 0.35 eV) is shown in the inset.\n"},{"uri":"https://djmolprogram.github.io/documentation/","title":"Documentation","tags":[],"description":"","content":"DJMol Table of Contents  Chapter 1: Introduction Chapter 2: DFTB+ Calculations Chapter 3: Modeling with Siesta Chapter 4: OpenMD Simulations Chapter 5: Python scripting with ASE Chapter 6: Tools of DJMol Chapter 7: Architecture of the Program Chapter 8: Software Applications Appendices  Python Scripting for DJMol Applications Installation of Python and NumPy Windows Subsystem Linux in DJMol Saved Data Demonstration Videos For Compiling/Installation of DJMol and Add-Ons Forthcoming Features    "},{"uri":"https://djmolprogram.github.io/installation/requirements/","title":"System Requirements","tags":[],"description":"","content":"DJMol System Requirements   Software:\n Windows 10-7 64 bit OS Java 1.8 or later, Python 3.x    Hardware:\n At least 20 GB free space to install DJMol and add-ons. Preferred RAM size is 4 GB or higher.    "},{"uri":"https://djmolprogram.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://djmolprogram.github.io/manual/","title":"Online Manual","tags":[],"description":"","content":""},{"uri":"https://djmolprogram.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]